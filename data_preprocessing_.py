# -*- coding: utf-8 -*-
"""Data_preprocessing_.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18qwHxIHuXFYa2AZqJGqWGMTNg0tEcStK
"""



from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
import cv2
from skimage import io,filters
import pandas as pd
from sklearn.metrics import pairwise_distances
import os
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from PIL import Image
# %matplotlib inline

image = cv2.imread('/set1sample5raw_0000.tif', cv2.IMREAD_COLOR)
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
image_height, image_width, _ = image.shape

"""#Data loader"""

# Set the path to your dataset folder
data_folder = '...'

# Load your images and convert them to a feature matrix
def load_images(folder, num_images=None):
    images = []
    count = 0

    for filename in os.listdir(folder):
        if num_images is not None and count >= num_images:
            break
        print(filename)
        img = Image.open(os.path.join(folder, filename))
        img_array = np.array(img)
        images.append(img_array.flatten())
        count += 1

    return np.array(images)

# Load the first 50 images and flatten them into feature vectors
num_images_to_load = 50
data = load_images(data_folder, num_images=num_images_to_load)
print("The data is loaded")

"""#Clustering"""

# Optimal number of clusters
optimal_clusters = 3

# Output folder for clustered images
output_folder = '/Clustered_tiff_images'

# Perform KMeans clustering with the optimal number of clusters
kmeans = KMeans(n_clusters=optimal_clusters, random_state=0)
cluster_labels = kmeans.fit_predict(data)

# Create an empty dictionary to store the mapping of filenames to cluster labels
filename_to_cluster = {}


# Iterate through the data points and their cluster labels
for i, cluster_label in enumerate(cluster_labels):
    # Retrieve the original filename for this data point
    original_filename = os.listdir(data_folder)[i]  # Assuming the list of filenames is in the same order as the data
    # Store the filename as the key and the cluster label as the value in the dictionary
    filename_to_cluster[original_filename] = cluster_label

# Display centroid images for each cluster
centroids = kmeans.cluster_centers_
print(centroids.shape)

# Calculate distances between data points and centroids
distances = pairwise_distances(data, centroids)
print(distances.shape)
# Create a DataFrame to store the distances
df_distances = pd.DataFrame(distances, columns=[f'Distance_to_Centroid_{i+1}' for i in range(optimal_clusters)])

# Add a column for the cluster label assigned to each image
df_distances['Cluster_Label'] = cluster_labels

# Create a column for image names using the dictionary
im = [original_filename for original_filename in os.listdir(data_folder)]
print(im)

# Map the image names to their cluster labels
image_names = [f'cluster_{cluster_labels[i]+1}_image_{im[i]}' for i in range(len(data))]
print(image_names)
df_distances['Image_Name'] = image_names
f = '/content/drive/' # Change this path as needed
# Define the output CSV file path
output_csv_path = os.path.join(f, 'cluster_distances.csv')

# Save the distances to a CSV file
df_distances.to_csv(output_csv_path, index=False)

print(f"Distances between images and centroids saved to {output_csv_path}")

"""Assiging images from image set 1 to their respective clusters"""

for idx, original_filename in enumerate(filename_to_cluster):
    cluster_num = filename_to_cluster[original_filename]
    cluster_folder = os.path.join(output_folder, f'cluster_{cluster_num+1}')
    print(cluster_folder)
    image_name = original_filename
    print(image_name)
    image_path = os.path.join(cluster_folder, image_name)

    # Create the directory if it doesn't exist
    os.makedirs(cluster_folder, exist_ok=True)

    image_reshaped = np.reshape(data[idx], (image_height, image_width, 3))
    print(idx)
    Image.fromarray(image_reshaped).save(image_path)

print("Images assigned to clusters and saved successfully.")

folder_path = '/content/drive/centroid_images'  # Change this path as needed
os.makedirs(folder_path, exist_ok=True)
for i, centroid_image in enumerate(centroids):
    print(centroid_image.shape)
    centroid_image_reshaped = centroid_image.reshape((image_height,image_width, 3))
    print(centroid_image_reshaped.shape)
    print(type(centroid_image_reshaped))
    image_filename = os.path.join(folder_path, f'centroid_cluster_{i+1}.png')
    Image.fromarray((centroid_image_reshaped).astype(np.uint8)).save(image_filename)


print("Centroid images saved successfully.")

"""###Thresholding of the centroid images"""

# Path to the folder containing your PNG images
image_folder = '/centroid_images' # Change this path as needed

# List all image files in the folder
image_files = [f for f in os.listdir(image_folder) if f.lower().endswith('.png')]

# Loop through each image
for image_file in image_files:
    # Read the image
    image_path = os.path.join(image_folder, image_file)
    image = cv2.imread(image_path)
    print(image.shape)

    # Reshape the image into a 2D array of pixels and 3 color values (RGB)
    pixel_vals = image.reshape((-1, 3))  # 3 for RGB channels

    # Convert to float type
    pixel_vals = np.float32(pixel_vals)
    # Calculate the mean of pixel values for thresholding
    mean_pixel_value = np.mean(pixel_vals)
    print(mean_pixel_value)

    # Apply binary thresholding
    _, thresholded_image = cv2.threshold(image, mean_pixel_value, 255, cv2.THRESH_TOZERO_INV)
    mask = (thresholded_image > np.min(thresholded_image))
    # Setting all corresponding pixels in the thresholded image to 255
    thresholded_image[mask] = 255
    print(np.unique(thresholded_image))
    print(thresholded_image.shape)

    # Convert thresholded_image to grayscale
    thresholded_image_gray = cv2.cvtColor(thresholded_image, cv2.COLOR_BGR2GRAY)
    print(thresholded_image_gray.shape)


    # Output folder for thresholded images
    output_folder = '/centers' # Change this path as needed
    os.makedirs(output_folder, exist_ok=True)

    # Save the thresholded image
    output_path = os.path.join(output_folder, f'thresholded_{image_file}')
    cv2.imwrite(output_path, thresholded_image_gray)


    plt.subplot(1, 2, 2)
    plt.imshow(thresholded_image_gray, cmap='gray')
    plt.title('Thresholded Image')
    plt.axis("off")

    plt.show()